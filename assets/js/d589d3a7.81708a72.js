"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[924],{6475:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started","title":"Getting Started","description":"Project SEMA-JOIN is a semantic table joining system developed based on Microsoft Research\'s SEMA-JOIN paper. Unlike traditional joins that require exact matches, Project SEMA-JOIN discovers and leverages semantic relationships between values to intelligently join tables.","source":"@site/docs/getting-started.md","sourceDirName":".","slug":"/","permalink":"/sema-join-docs/docs/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"slug":"/"},"sidebar":"tutorialSidebar","next":{"title":"Installation","permalink":"/sema-join-docs/docs/installation"}}');var n=s(4848),a=s(8453);const o={sidebar_position:1,slug:"/"},r="Getting Started",l={},c=[{value:"What is Project SEMA-JOIN?",id:"what-is-project-sema-join",level:2},{value:"System Components",id:"system-components",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Relationship to the Research Paper",id:"relationship-to-the-research-paper",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,n.jsx)(t.p,{children:"Project SEMA-JOIN is a semantic table joining system developed based on Microsoft Research's SEMA-JOIN paper. Unlike traditional joins that require exact matches, Project SEMA-JOIN discovers and leverages semantic relationships between values to intelligently join tables."}),"\n",(0,n.jsx)(t.h2,{id:"what-is-project-sema-join",children:"What is Project SEMA-JOIN?"}),"\n",(0,n.jsx)(t.p,{children:"Traditional database joins and even fuzzy joins are limited to exact or syntactically similar matches. Project SEMA-JOIN goes beyond this by understanding semantic relationships that exist in your data."}),"\n",(0,n.jsx)(t.p,{children:"Project SEMA-JOIN automatically discovers these relationships by analyzing statistical co-occurrence patterns across a corpus of tables. When two values frequently appear together in tables, they likely have a semantic relationship."}),"\n",(0,n.jsx)(t.p,{children:"For example, Project SEMA-JOIN can discover relationships such as:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:'Entity variations: "USA" and "United States"'}),"\n",(0,n.jsx)(t.li,{children:"Hierarchical relationships: Cities to their states"}),"\n",(0,n.jsx)(t.li,{children:'Brand relationships: "iPhone" to "Apple"'}),"\n",(0,n.jsx)(t.li,{children:"Code mappings: Country codes to country names"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"These relationships are quantified using Pointwise Mutual Information (PMI) scores calculated from the corpus."}),"\n",(0,n.jsx)(t.h2,{id:"system-components",children:"System Components"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Backend Service (Python/FastAPI)"}),"\nThe core orchestration service that coordinates all join operations. It implements the CS-JP-LP and RS-JP algorithms, manages the application database (MySQL), handles table uploads and storage, processes bridge table creation, and calls the Go service for PMI calculations. The backend also manages the Linear Programming solver for CS-JP-LP optimization. Runs on port 8000."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Go Service"}),"\nHigh-performance PMI calculation engine that processes co-occurrence statistics from the corpus database. Uses optimized bitmap operations for fast computation of both row-level PMI scores (for RS-JP) and column-level quad scores (for CS-JP-LP). Runs on port 8080."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Web Interface (Next.js)"}),"\nProvides an intuitive React-based interface for uploading tables, selecting join columns, configuring algorithms, and viewing results. Runs on port 3000."]}),"\n",(0,n.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,n.jsx)(t.p,{children:"Project SEMA-JOIN operates in two stages:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Stage 1: Corpus Preparation"}),"\nThe system ingests a corpus of tables and stores the values with additional metadata (e.g., tableID, rowID, columnID) in order to caluculate the co-occurrence statistics later on. For now, the data is just structured and stored."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Stage 2: Table Joining"}),"\nWhen joining two tables, the backend service coordinates the process: it extracts values from selected columns, calls the Go service to calculate PMI scores on-demand for those specific values, then applies the chosen algorithm (RS-JP or CS-JP-LP) to determine the optimal join mappings. The Go service queries the corpus database for specific tables and uses optimized bitmap operations to compute PMI scores in real-time. This allows the system to identify which rows have strong semantic relationships, even when values don't match exactly."]}),"\n",(0,n.jsx)(t.h2,{id:"relationship-to-the-research-paper",children:"Relationship to the Research Paper"}),"\n",(0,n.jsx)(t.p,{children:"This implementation is based on the Microsoft Research SEMA-JOIN paper and implements the core algorithms:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"CS-JP-LP (Column Score Join Prediction with Linear Programming)"})," - Uses column-level semantic compatibility scores with LP optimization to find the optimal join mapping that maximizes aggregate pairwise correlation. Provides the highest quality results (F-score) with a 2-approximation guarantee."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"RS-JP (Row Score Join Prediction)"})," - A simplified variant that uses row-level PMI scores for greedy matching. Optimizes each join decision individually and provides high performance, but is suseptible to missing global context."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"PMI-based semantic relationship discovery"})," - Uses Pointwise Mutual Information (PMI) scores calculated from statistical co-occurrence in a large table corpus (100M+ tables) to quantify semantic relationships at both row-level and column-level."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Automatic bridge table creation"})," - Creates bridge tables that map semantically related values even when they don't match exactly (e.g., country codes to country names, stock tickers to company names)."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"This implementation extends the research with additional features:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Web-based user interface for accessibility"}),"\n",(0,n.jsx)(t.li,{children:"AI-powered column matching to address the future work identified in the paper"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,n.jsxs)(t.p,{children:["Follow the ",(0,n.jsx)(t.a,{href:"./installation",children:"Installation"})," guide to set up Project SEMA-JOIN and build your semantic relationship database."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var i=s(6540);const n={},a=i.createContext(n);function o(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);